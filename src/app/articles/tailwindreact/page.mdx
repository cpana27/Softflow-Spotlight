import {ArticleLayout} from '../../../components/ArticleLayout'

export const article = {
  author: 'Christian Pana',
  date: '2025-01-03',
  title: 'Modern UI-Entwicklung mit React, Tailwind CSS und Next.js',
  description:
    'Wie ich mit dem perfekten Technologie-Stack schnellere, bessere und wartbare Frontend-Anwendungen entwickle: Eine Kombination aus React für Komponenten, Tailwind CSS für Design und Next.js für Performance.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

Als Frontend-Entwickler bin ich ständig auf der Suche nach dem optimalen Tech-Stack, der Produktivität, Performance und Wartbarkeit vereint. Nach Jahren des Experimentierens mit verschiedenen Frameworks und Bibliotheken habe ich meine ideale Kombination gefunden: React für die Komponenten-Struktur, Tailwind CSS für schnelles und konsistentes Design und Next.js als leistungsstarkes Framework, das alles zusammenhält.

## Warum diese Kombination unschlagbar ist

Wenn diese drei Technologien zusammenkommen, entsteht ein Workflow, der sowohl für individuelle Entwickler als auch für Teams außergewöhnlich effizient ist. Hier ist ein einfaches Beispiel für eine Produktkarte, die alle drei Technologien nutzt:

```jsx
// components/ProductCard.jsx
export default function ProductCard({ product }) {
  return (
    <div className="group relative rounded-lg border border-zinc-200 bg-white p-4 shadow-sm transition-all hover:shadow-md dark:border-zinc-700 dark:bg-zinc-800">
      <div className="aspect-w-16 aspect-h-9 mb-3 overflow-hidden rounded-md">
        <img
          src={product.imageUrl}
          alt={product.name}
          className="h-full w-full object-cover transition-transform duration-200 group-hover:scale-105"
        />
      </div>
      <h3 className="text-lg font-medium text-zinc-900 dark:text-zinc-100">
        {product.name}
      </h3>
      <p className="mt-1 text-sm text-zinc-600 dark:text-zinc-400">
        {product.description}
      </p>
      <div className="mt-3 flex items-center justify-between">
        <span className="font-semibold text-zinc-900 dark:text-zinc-100">
          {product.price} €
        </span>
        <button className="rounded-md bg-blue-600 px-3 py-1.5 text-sm font-medium text-white transition-colors hover:bg-blue-700">
          Zum Warenkorb
        </button>
      </div>
    </div>
  )
}
```

Das Schöne an diesem Ansatz ist die klare Trennung von Struktur (React), Styling (Tailwind) und Funktionalität. Und das Beste daran: kein Wechsel zwischen CSS- und JavaScript-Dateien mehr.

## Next.js: Das Framework, das alles zusammenbringt

Next.js hat die Art, wie ich React-Anwendungen entwickle, grundlegend verändert. Mit seiner server-seitigen Rendering-Fähigkeit, dem intelligenten Routing und den optimierten Builds sorgt es für unvergleichliche Performance.

Hier ist ein Beispiel für eine einfache Next.js-Seite, die Produkte aus einer API lädt:

```jsx
// pages/products.js
import { useState } from 'react'
import ProductCard from '@/components/ProductCard'

export default function ProductsPage({ initialProducts }) {
  const [products, setProducts] = useState(initialProducts)
  const [filter, setFilter] = useState('')

  const filteredProducts = products.filter(product =>
    product.name.toLowerCase().includes(filter.toLowerCase())
  )

  return (
    <div className="mx-auto max-w-7xl px-4 py-8 sm:px-6 lg:px-8">
      <div className="mb-8 flex flex-col justify-between gap-4 sm:flex-row sm:items-center">
        <h1 className="text-3xl font-bold tracking-tight text-zinc-900 dark:text-zinc-100">
          Unsere Produkte
        </h1>
        <div className="w-full max-w-xs">
          <input
            type="text"
            placeholder="Produkte suchen..."
            value={filter}
            onChange={(e) => setFilter(e.target.value)}
            className="w-full rounded-md border border-zinc-300 px-4 py-2 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-100"
          />
        </div>
      </div>

      <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        {filteredProducts.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  )
}

export async function getStaticProps() {
  // In einer realen Anwendung würde dies von einer API kommen
  const initialProducts = [
    {
      id: 1,
      name: "Entwickler-Notebook",
      description: "Leistungsstarkes Notebook für Programmierer",
      price: 1499,
      imageUrl: "/images/products/laptop.jpg"
    },
    // Weitere Produkte...
  ]

  return {
    props: {
      initialProducts
    },
    revalidate: 60 * 60 // Jede Stunde aktualisieren
  }
}
```

## Tailwind CSS: Effizienz und Konsistenz im Design

Tailwind CSS hat meinen Design-Workflow revolutioniert. Der utility-first Ansatz ermöglicht es mir, schnell und konsistent zu gestalten, ohne zwischen CSS-Dateien hin und her zu wechseln.

Viele haben anfängliche Bedenken wegen der "sperrigen" Klassen-Attribute. Aber die Produktivitätssteigerung ist enorm. Mit dem neuen JIT-Compiler (Just-In-Time) ist Tailwind zudem schneller und leichter denn je.

```jsx
// components/Alert.jsx
export function Alert({ type = 'info', title, children }) {
  const styles = {
    info: 'bg-blue-50 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300',
    success: 'bg-green-50 text-green-800 dark:bg-green-900/30 dark:text-green-300',
    warning: 'bg-yellow-50 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300',
    error: 'bg-red-50 text-red-800 dark:bg-red-900/30 dark:text-red-300',
  }

  return (
    <div className={`rounded-md p-4 ${styles[type]}`}>
      <div className="flex">
        <div className="flex-shrink-0">
          {/* Icon based on type */}
        </div>
        <div className="ml-3">
          <h3 className="text-sm font-medium">{title}</h3>
          <div className="mt-2 text-sm opacity-90">{children}</div>
        </div>
      </div>
    </div>
  )
}
```

Dank der intelligenten Tailwind-Konfiguration kann ich ein Design-System aufbauen, das konsistent in der gesamten Anwendung verwendet wird.

## React: Komponenten-basierte Architektur

Was ich an React am meisten schätze, ist die Möglichkeit, komplexe UIs in kleine, wiederverwendbare Komponenten zu zerlegen. Dies führt zu saubererem, wartbarerem Code und weniger Redundanz.

Die Einführung von React Hooks hat die Art, wie wir Komponenten schreiben, nochmals vereinfacht:

```jsx
// hooks/useLocalStorage.js
import { useState, useEffect } from 'react'

export function useLocalStorage(key, initialValue) {
  // Zustand initialisieren
  const [storedValue, setStoredValue] = useState(() => {
    if (typeof window === 'undefined') {
      return initialValue
    }

    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(error)
      return initialValue
    }
  })

  // Wert im localStorage speichern, wenn sich storedValue ändert
  useEffect(() => {
    if (typeof window !== 'undefined') {
      try {
        window.localStorage.setItem(key, JSON.stringify(storedValue))
      } catch (error) {
        console.error(error)
      }
    }
  }, [key, storedValue])

  return [storedValue, setStoredValue]
}
```

Dieser Hook kann nun überall in der Anwendung verwendet werden, um Zustand persistent im Browser zu speichern.

## Praktische Projektstruktur

Ein weiterer Vorteil dieses Stacks ist die klare Projektstruktur, die sich daraus ergibt. So sieht ein typisches Projekt bei mir aus:

```
├── components/        # Wiederverwendbare UI-Komponenten
│   ├── ui/            # Basis-UI-Komponenten (Buttons, Cards, etc.)
│   ├── layout/        # Layout-Komponenten (Header, Footer, etc.)
│   └── features/      # Feature-spezifische Komponenten
├── hooks/             # Eigene React Hooks
├── lib/               # Hilfsfunktionen und Utilities
├── pages/             # Next.js-Seiten und API-Routes
├── public/            # Statische Assets
├── styles/            # Globale Styles und Tailwind-Konfiguration
└── context/           # React Context für globalen Zustand
```

## Performance-Optimierung mit Next.js

Next.js bietet zahlreiche Möglichkeiten zur Performance-Optimierung. Eines meiner Lieblingsfeatures ist die automatische Bildoptimierung:

```jsx
import Image from 'next/image'

export function OptimizedImage({ src, alt }) {
  return (
    <div className="relative h-64 w-full overflow-hidden rounded-lg">
      <Image
        src={src}
        alt={alt}
        fill
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        className="object-cover"
        priority={false}
        loading="lazy"
      />
    </div>
  )
}
```

Diese Komponente optimiert Bilder automatisch, reduziert ihre Größe, lädt sie verzögert und bietet responsive Größenoptionen – alles ohne zusätzliche Bibliotheken.

## Das Beste aus beiden Welten: SSR und CSR

Mit Next.js kann ich wählen, welcher Rendering-Ansatz für jede Seite am besten geeignet ist:

- `getStaticProps` und `getStaticPaths` für vollständig statische Seiten
- `getServerSideProps` für dynamische, serverseitig gerenderte Seiten
- Client-seitige Datenabfrage für interaktive Bereiche

Diese Flexibilität ist genau das, was moderne Web-Anwendungen brauchen – die perfekte Balance zwischen Performance und Interaktivität.

## Fazit

Die Kombination aus React, Tailwind CSS und Next.js bietet mir alles, was ich für schnelle, effiziente und wartbare Frontend-Entwicklung benötige. Nach mehr als fünf Jahren Entwicklungserfahrung ist dies der Stack, auf den ich mich für nahezu jedes Projekt verlasse.

Die drei Technologien ergänzen sich perfekt und ermöglichen es mir, mich auf das Wesentliche zu konzentrieren: großartige Benutzererfahrungen zu schaffen. Weniger Zeit mit Konfiguration und CSS-Debugging bedeutet mehr Zeit für Features und Optimierungen, die wirklich zählen.

Wenn du noch nicht mit dieser Kombination gearbeitet hast, kann ich sie nur wärmstens empfehlen. Der anfängliche Lernaufwand wird durch die langfristigen Vorteile bei weitem aufgewogen.